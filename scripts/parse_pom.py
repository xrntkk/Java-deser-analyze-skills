#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
依赖分析脚本 (Dependency Analyzer)
功能：
1. 解析 pom.xml 生成依赖清单
2. 扫描 lib/ 或 BOOT-INF/lib/ 下的 .jar 文件 (针对反编译 Fat JAR)
3. 生成合并的 XML 依赖清单
"""

import os
import re
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import List, Dict


def find_files(project_path: str, pattern: str) -> List[Path]:
    """递归查找文件"""
    return list(Path(project_path).rglob(pattern))


def parse_pom(pom_file: Path) -> List[Dict]:
    """解析单个 POM 文件"""
    dependencies = []
    try:
        tree = ET.parse(pom_file)
        root = tree.getroot()
        
        # 处理命名空间
        ns = {'maven': 'http://maven.apache.org/POM/4.0.0'}
        if root.tag.startswith('{'):
            ns_uri = root.tag[1:root.tag.index('}')]
            ns = {'maven': ns_uri}

        for dep in root.findall('.//maven:dependency', ns):
            group = dep.find('maven:groupId', ns)
            artifact = dep.find('maven:artifactId', ns)
            version = dep.find('maven:version', ns)
            scope = dep.find('maven:scope', ns)

            if group is not None and artifact is not None:
                dependencies.append({
                    'source': 'pom',
                    'file': str(pom_file),
                    'groupId': group.text,
                    'artifactId': artifact.text,
                    'version': version.text if version is not None else 'unknown',
                    'scope': scope.text if scope is not None else 'compile'
                })
    except Exception as e:
        print(f"[!] 解析 POM 失败: {pom_file} - {e}")
    
    return dependencies


def parse_jar_filename(jar_path: Path) -> Dict:
    """从 jar 文件名推断依赖信息"""
    filename = jar_path.name
    # 尝试匹配 name-version.jar
    # 例如: commons-collections-3.2.1.jar
    match = re.match(r'(.+?)-(\d[\d\w\.-]*)\.jar$', filename)
    
    if match:
        artifact_id = match.group(1)
        version = match.group(2)
        group_id = artifact_id  # 无法准确获知 groupId，暂用 artifactId 代替，或标记为 inferred
    else:
        # 无法解析版本
        artifact_id = filename.replace('.jar', '')
        version = 'unknown'
        group_id = artifact_id

    return {
        'source': 'jar',
        'file': str(jar_path),
        'groupId': group_id,  # Note: GroupId is guessed
        'artifactId': artifact_id,
        'version': version,
        'scope': 'system'
    }


def analyze_dependencies(project_path: str) -> List[Dict]:
    all_deps = []
    
    # 1. Scan POM files
    pom_files = find_files(project_path, 'pom.xml')
    print(f"[*] Found {len(pom_files)} pom.xml files")
    for pom in pom_files:
        all_deps.extend(parse_pom(pom))

    # 2. Scan JAR files (Fat JAR / Decompiled lib)
    jar_files = find_files(project_path, '*.jar')
    print(f"[*] Found {len(jar_files)} .jar files")
    for jar in jar_files:
        all_deps.append(parse_jar_filename(jar))
        
    return all_deps


def merge_dependencies(deps: List[Dict]) -> List[Dict]:
    """合并并去重"""
    merged = {}
    for dep in deps:
        # Key: artifactId (忽略 groupId，因为 jar 推断的 groupId 不准)
        key = dep['artifactId']
        
        if key not in merged:
            merged[key] = dep
        else:
            # 优先保留有版本的
            if dep['version'] != 'unknown' and merged[key]['version'] == 'unknown':
                merged[key] = dep
            # 优先保留 POM 来源 (通常信息更全)
            elif dep['source'] == 'pom' and merged[key]['source'] == 'jar':
                 merged[key] = dep
                 
    return list(merged.values())


def save_to_xml(deps: List[Dict], output_file: str):
    """保存为 Maven 兼容的 XML"""
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write('<!-- Generated by Java-Deser-Skills -->\n')
        f.write('<dependencies>\n')
        
        # Sort by artifactId
        for dep in sorted(deps, key=lambda x: x['artifactId']):
            f.write('    <dependency>\n')
            # 如果是 JAR 推断的，groupId 可能是 artifactId，添加注释
            if dep['source'] == 'jar':
                 f.write(f'        <!-- Inferred from Jar: {Path(dep["file"]).name} -->\n')
            
            f.write(f'        <groupId>{dep["groupId"]}</groupId>\n')
            f.write(f'        <artifactId>{dep["artifactId"]}</artifactId>\n')
            
            if dep['version'] != 'unknown':
                f.write(f'        <version>{dep["version"]}</version>\n')
            
            f.write('    </dependency>\n')
            
        f.write('</dependencies>\n')
    print(f"[*] XML dependency list saved to: {output_file}")


def save_to_markdown(deps: List[Dict], output_file: str):
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# Dependency Analysis Report\n\n")
        f.write(f"Total Unique Dependencies: {len(deps)}\n\n")
        f.write("| Source | ArtifactId | Version | File |\n")
        f.write("| :--- | :--- | :--- | :--- |\n")
        
        for dep in sorted(deps, key=lambda x: x['artifactId']):
             f.write(f"| {dep['source']} | {dep['artifactId']} | {dep['version']} | {os.path.basename(dep['file'])} |\n")
             
    print(f"[*] Markdown report saved to: {output_file}")


if __name__ == '__main__':
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python parse_pom.py <project_path> [output_prefix]")
        sys.exit(1)
        
    project_path = sys.argv[1]
    output_prefix = sys.argv[2] if len(sys.argv) > 2 else 'deps'
    
    print(f"[*] Analyzing dependencies in: {project_path}")
    
    all_deps = analyze_dependencies(project_path)
    merged_deps = merge_dependencies(all_deps)
    
    if not merged_deps:
        print("[!] No dependencies found (no pom.xml or .jar files).")
    else:
        save_to_xml(merged_deps, f"{output_prefix}_dependencies.xml")
        save_to_markdown(merged_deps, f"{output_prefix}_dependencies.md")
