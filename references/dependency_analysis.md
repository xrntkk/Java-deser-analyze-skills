# Dependency Analysis Guide

> Detailed guidance for analyzing dependencies and mining gadget chains in decompiled/Fat JAR projects.

## Fat JAR Structure

Typical Spring Boot Fat JAR:
```
application.jar
├── BOOT-INF/
│   ├── classes/          # Application code (decompiled)
│   └── lib/              # Dependencies as .jar files
├── META-INF/
│   └── maven/            # ← Most reliable dependency metadata
│       └── groupId/artifactId/pom.properties
└── org/springframework/  # Spring Boot loader
```

Non-Maven Fat JAR (e.g., custom assembly, Ant, Gradle Shadow with no POM):
```
application/
├── resources/            # All classes merged into flat package dirs
│   ├── aj/               # ← AspectJ Weaver shaded ASM (no META-INF/maven entry!)
│   ├── org/aspectj/      # AspectJ core classes
│   ├── mozilla/          # Mozilla Rhino
│   ├── META-INF/maven/   # Only present for Maven-built deps
│   └── com/app/          # Application code
└── sources/
```

**Key Insight**: Non-Maven bundled libraries (e.g., AspectJ Weaver in fileury5) do NOT have
`META-INF/maven` entries. They must be identified by package directory patterns.

---

## Dependency Source Priority

| Priority | Source | Reliability | Method |
|:--------:|--------|-------------|--------|
| 1 (Best) | `META-INF/maven/pom.properties` | Exact groupId/artifactId/version | Auto-parsed |
| 2 | `pom.xml` (project root) | Declared deps only, may miss transitives | Auto-parsed |
| 3 | `gradle.lockfile` / `*.lockfile` | Exact versions, most reliable for Gradle | Auto-parsed |
| 4 | `build.gradle` / `build.gradle.kts` | Declared deps, version may be `$var` | Auto-parsed + LLM for unknowns |
| 5 | JAR filename | Version usually OK, groupId guessed | Auto-parsed + LLM verify |
| 6 | Package directory scan | For non-Maven/Gradle libs, needs mapping | Auto-matched + LLM verify |

---

## Source 1: META-INF/maven Scanning (Highest Priority)

When a fat JAR is unpacked, each Maven-built dependency typically embeds:
```
META-INF/maven/<groupId>/<artifactId>/pom.properties
```

Example `pom.properties` content:
```properties
#Generated by Apache Maven
version=3.2.2
groupId=commons-collections
artifactId=commons-collections
```

**Use this source first** — it provides the exact Maven coordinates without any guessing.

Limitation: Libraries NOT built with Maven (or with stripped manifests) will be absent here.

---

## Source 2: Gradle Lockfile & Build Scripts

### gradle.lockfile (Priority 3 — Highest for Gradle Projects)

When a Gradle project uses dependency locking, each configuration generates a lockfile:
```
# gradle.lockfile format
commons-collections:commons-collections:3.2.2=compileClasspath,runtimeClasspath
com.alibaba:fastjson:1.2.83=compileClasspath,runtimeClasspath,testCompileClasspath
```

**Use this in preference to build.gradle** — versions are exact and fully resolved (no variables).

Lockfile locations:
- `gradle.lockfile` (root, single-config locking)
- `gradle/dependency-locks/*.lockfile` (per-configuration locking)

### build.gradle / build.gradle.kts (Priority 4 — Fallback)

When no lockfile exists, parse the Gradle build scripts directly:

```groovy
// Groovy DSL — common patterns detected by script
implementation 'commons-collections:commons-collections:3.2.2'
implementation("com.alibaba:fastjson:1.2.83")
compile group: 'org.springframework', name: 'spring-core', version: '5.3.20'
```

```kotlin
// Kotlin DSL — also supported
implementation("commons-collections:commons-collections:3.2.2")
```

**Limitation**: If version is a variable (`$springVersion`, `libs.versions.spring`), the script marks
it as `unknown` and adds it to the LLM verification prompt for manual resolution.

---

## Source 3: Dependency Inference from JAR Files

When `pom.xml` and Gradle files are both missing or incomplete, infer from JAR filenames:

| Filename Pattern | Inferred Dependency |
|-----------------|---------------------|
| `commons-collections-3.2.2.jar` | `commons-collections:commons-collections:3.2.2` |
| `spring-core-5.3.20.jar` | `org.springframework:spring-core:5.3.20` |
| `fastjson-1.2.83.jar` | `com.alibaba:fastjson:1.2.83` |

**Always LLM-verify the groupId** — filename only provides artifactId reliably.

---

## Source 4: Package Directory Scanning (Non-Maven/Gradle Bundled Libs)

For projects where dependencies are merged as `.class` files (no JARs, no `META-INF/maven` entries),
scan the package directory structure and match against known patterns.

### Known Package Prefix → Library Mappings

| Package Prefix | Library | groupId | artifactId | Notes |
|:---------------|---------|---------|------------|-------|
| `aj/` | AspectJ Weaver | `org.aspectj` | `aspectjweaver` | Shaded ASM inside aspectjweaver |
| `mozilla/` | Rhino | `rhino` | `js` | Mozilla Rhino JS engine |
| `javassist/` | Javassist | `org.javassist` | `javassist` | Bytecode manipulation |
| `ognl/` | OGNL | `ognl` | `ognl` | Object-Graph Navigation Language |
| `groovy/` | Groovy | `org.codehaus.groovy` | `groovy` | Groovy runtime |
| `bsh/` | BeanShell | `org.beanshell` | `bsh` | BeanShell scripting |
| `com/caucho/` | Resin/Hessian | `com.caucho` | `resin` | Hessian protocol |
| `com/esotericsoftware/` | Kryo | `com.esotericsoftware` | `kryo` | Kryo serialization |
| `com/thoughtworks/xstream/` | XStream | `com.thoughtworks.xstream` | `xstream` | XStream XML serialization |
| `com/rometools/rome/` | ROME | `com.rometools` | `rome` | RSS/Atom (toString gadget) |
| `com/sun/syndication/` | ROME (old) | `rome` | `rome` | ROME older package |
| `com/alibaba/fastjson/` | Fastjson | `com.alibaba` | `fastjson` | Fastjson JSON |
| `com/fasterxml/jackson/` | Jackson | `com.fasterxml.jackson.core` | `jackson-databind` | Jackson JSON |
| `org/yaml/snakeyaml/` | SnakeYAML | `org.yaml` | `snakeyaml` | YAML parser |
| `org/mvel2/` | MVEL2 | `org.mvel` | `mvel2` | MVEL expression engine |
| `net/sf/json/` | json-lib | `net.sf.json-lib` | `json-lib` | JSON-lib |
| `clojure/` | Clojure | `org.clojure` | `clojure` | Clojure runtime |
| `org/h2/` | H2 | `com.h2database` | `h2` | H2 in-memory DB |

**Real case**: fileury5 project contains `aj/org/objectweb/asm/` package — this is AspectJ Weaver's
internally relocated ASM library. No `META-INF/maven` entry exists for `aspectjweaver` because it
was bundled via non-standard tooling. Only package directory scanning reveals it.

---

## LLM二次校验 Prompt

The script auto-generates `{prefix}_llm_verify_prompt.md` when JAR or package_dir sources are found.
Feed this prompt to an LLM to:
1. Verify/correct inferred `groupId` for JAR-filename-based deps
2. Confirm package-dir matched libraries
3. Identify remaining unknown package prefixes

### Template for Manual LLM Verification

```
You are a Java dependency analysis expert.

The following dependencies were automatically extracted. Some have uncertain groupIds or versions.
Please verify and correct where needed, focusing on deserialization-relevant libraries.

[Paste contents of {prefix}_llm_verify_prompt.md here]

Additional context:
- Project type: [Spring Boot / Custom Fat JAR / Ant build / etc.]
- Known package dirs present: [list top-level dirs from project]
- Any DTD/properties files visible: [e.g., aspectj_1_5_0.dtd → implies AspectJ Weaver]

For each unidentified package, check:
1. Is this a known shaded/relocated library?
2. What is the Maven groupId:artifactId:version?
3. Does this library have known deserialization gadgets?
```

---

## Multi-Chain Mining Strategy

**Core Principle: Do NOT stop at the first chain!**

Real environments have various unknown restrictions. The goal is to find **as many potential paths as possible**.

### Chain Categories

| Category | Examples | Typical Use |
|----------|----------|-------------|
| **Transformer-based** | CC1-7, CB1-5 | Runtime.exec via reflection |
| **Template-based** | TemplatesImpl | Class loading / bytecode execution |
| **JNDI-based** | JdbcRowSetImpl | Remote class loading |
| **ToString triggers** | ROME, XString | Indirect chain entry |
| **Second Deserialize** | SignedObject | Bypass shallow checks |

### Version-Specific Analysis

For each dependency, check:

1. **Official Mitigations**: Does this version have patches?
   - Example: CC 3.2.2+ has `InvokerTransformer` restriction

2. **Known Bypasses**: Are there documented bypasses?
   - Example: CC 3.2.2 bypass via `InstantiateTransformer`

3. **JDK Compatibility**: Does the chain require specific JDK?
   - Example: Some chains break after JDK 8u20

---

## LLM Prompt Template for Chain Mining

```
You are a specialized Java Deserialization Vulnerability Researcher.

Context:
You will analyze dependency lists from POM declarations and JAR inferences.
Focus on practical attack vectors relevant to the given dependencies.

Dependency List:
[Insert dependencies.xml content]

Tasks:
1. Extract Core Vulnerability Surface
2. Full Gadget Chain Mining (ALL possible chains)
3. Dependency Exploitation Analysis (per chain)
4. Advanced Chain Combination Analysis
5. Noise Filtering (ignore URLDNS, DoS)
6. Structured Output (priority-ordered)

Quality Requirements:
- Verify version compatibility
- Cross-check against CVE/NVD
- Self-correct if chains are missed
- Note version ambiguities
- Flag any deps marked [VERIFY] in the XML — their groupId may be incorrect
```

---

## Chain Combination Techniques

### Second Deserialization
Wrap serialized data to bypass shallow class checks:
- `java.security.SignedObject`
- `javax.management.remote.rmi.RMIConnector`

### Multi-Hop Chaining
Connect multiple partial chains:
- `TiedMapEntry` -> `BadAttributeValueExpException` -> `toString` trigger
- `LazyMap` + alternative `Transformer` implementations

---

## Transitive Dependency Consideration

When analyzing dependencies, consider:
1. **Declared vs Actual**: Fat JARs include transitive deps
2. **Version Conflicts**: Multiple versions of same library
3. **Shaded Libraries**: Relocated packages (com.example.shaded.xxx)
4. **Non-Maven Bundled**: Libs merged as class files with no metadata → use package scanning
5. **DTD/Schema files as hints**: e.g., `aspectj_1_5_0.dtd` confirms AspectJ Weaver presence
